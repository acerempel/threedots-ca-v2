---
id: bb579bda-b8cc-476e-b3de-a4eb9794b55e
published: false
blueprint: posts
title: 'Upon software maintenance'
updated_by: ef566878-06e2-4591-9b05-2130076004d2
updated_at: 1753308905
content:
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Why must software be maintained? It is not like a house; it does not, when left to its own devices, fall apart. The hardware it runs on certainly does; and it seems that the material condition of software is that hardware; nonetheless, it is appropriate to regard a piece of software as a distinct artifact. (This already leads to all kinds of complications, such as: what constitutes '
      -
        type: text
        marks:
          -
            type: italic
        text: one
      -
        type: text
        text: ' piece of software? How can a piece of software be regarded as a entity in its own right, separate both from any hardware '
      -
        type: text
        marks:
          -
            type: italic
        text: and
      -
        type: text
        text: ' from the other software it depends on in order to be able to run? Can we really take for granted a clear distinction between hardware and software? (Where does firmware fall?) It might be helpful to define a piece of software in terms of the semantics of the programming languages in which it is written. Although the plural there poses problems ...)'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Another way of coming at the question: It is generally acknowledged in the world of software development that the life of a piece of software is the life of the community of people that develops and maintains it. Nobody wants to use software that lacks such a community or whose development community is moribund – such software is "unmaintained" and if it is presumed to remain that way it is considered "dead". But why does software need to be alive in the first place?'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'A number of reasons come to mind:'
  -
    type: bulletList
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'Bugs may be discovered in the software that then must be fixed'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: "The software's users may desire new capabilities to be added to the software"
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'The developers of the software may wish to update its software dependencies (why? perhaps in order to benefit from bug fixes etc. in '
              -
                type: text
                marks:
                  -
                    type: italic
                text: those
              -
                type: text
                text: ' pieces of software), and some of these updated dependencies may require changes to the dependent software'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: "The software's users may wish to run the software in a environment in which it is not yet capable of running, so the developers may add that capability. (E.g. porting it to a new processor architecture or operating system.)"
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: "The developers may wish to improve the software's performance, that is, to make more efficient its use of computing resources"
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'The developers may wish to make changes to the software that are not expected to affect its observable behaviour, but that are beneficial in connection with the ways in which the developers relate to the software as developers, i.e. that facilitate the development process somehow – changes that make the software more amenable to auditing or to static analysis, or that make it more modular, or "cleaner", for example'
  -
    type: paragraph
    content:
      -
        type: text
        text: "But this doesn't yet get at the paradox. Software, being immaterial, ought to possess the kind of perfection that philosophers have always associated with immateriality. Yet software manifestly demands continual maintenance and improvement to such a degree as rivals the most maintenance-intensive material artifacts."
  -
    type: paragraph
    content:
      -
        type: text
        text: "One reason for this is that, precisely because software is immaterial, it is mutable in a way that no material artifact is. Other immaterial things are also mutable in a way that is peculiar to their immateriality – such as a natural language. A natural language's existence, however, and therefore its ability to change, is dispersed across innumerably many and unfathomably diverse speakers and communities of speakers and circumstances in which speech occurs. The change it undergoes is therefore necessarily very slow and uncoordinated and it cannot be controlled by any one person or group of people. If someone says they have codified a natural language in a written document and can change the language as they please by changing that document, then they are mistaken, because that document is something quite different from a natural language."
  -
    type: paragraph
    content:
      -
        type: text
        text: "A piece of music is also immaterial – and quite mutable. It may be codified in a written document using standard notation, or it may be learned only by ear; in either case, it can be changed at will by changing the written document or by performing one's own variation on it, respectively. Like a piece of software, and unlike a natural language, it is a single artifact, rather than a system of communication and expression that is distribution across uncountable communities of speakers (and it may, like a piece of software, be defined by a written document); this greatly facilitates mutability. Unlike software, there is not much pressure on a piece of music to change. If a composer wishes to respond to new demands that they feel the cultural moment in which they and their music are situated makes on art, they are more likely to compose a new piece than to revise an existing one. More importantly (I feel), a piece of music does not, unlike (by analogy) software, actively depend on the performance of specific other pieces of music in specific ways in order for "
      -
        type: text
        marks:
          -
            type: italic
        text: it
      -
        type: text
        text: ' to be performed. Virtually no piece of software, by contrast, stands alone; in order for my web browser to continue to run, my window manager, my kernel, etc., must continue to run – on the same hardware, in the same environment.'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The other element is complexity. A piece of software can be arbitrarily complicated. Can a natural language, a piece of music, be just as complicated? In practice, I think, no. The complexity of a natural language (and just how do we measure that, anyway? what does it even mean?—) is bounded by the requirement that every person be able to use it effectively enough to meet their own social needs having only learned by the example of their parents and peers and by a certain degree of explicit training in school – and by the requirement that all these users of a language must learn more or less the '
      -
        type: text
        marks:
          -
            type: italic
        text: same
      -
        type: text
        text: ' language.  The complexity of a piece of music is bounded by the capacities of those who might wish to perform it and by their ability to co-ordinate this performance in real time. (Notably, this really limits the number of performers who can participate in the same performance.) But there is no limit to the complexity of a piece of software, because the running software involves no people.'
  -
    type: paragraph
    content:
      -
        type: text
        text: "And I think that gets to the heart of the matter: because I believe the best analogy for a piece of software is an organization of people following rules. The things we now use software to do – calculate payroll, set type, send and receive messages across a distributed network – have otherwise been done by people – obviously. But the most complicated software applications arise where there is either a very complicated set of rules to follow (payroll) or where there is a need to talk to and co-ordinate with other pieces of software (mail). Well – this bit of my argument is especially underbaked, so I'll leave it at that for now."
---
